#code 
import torch
import torch.nn as nn
import torch.optim as optim
import numpy as np
import os
import pandas as pd
import sys
from scipy.io import wavfile
from scipy.signal import spectrogram

# --- DATA LOADING AND PREPARATION ---
def load_data(audio_base_dir, spectrogram_dir, csv_file_path):
    """
    Checks for spectrograms, creates them if they don't exist,
    and then loads both the spectrogram data and the corresponding T60 values.
    """
    try:
        df_metadata = pd.read_csv(csv_file_path)
    except FileNotFoundError:
        print(f"ERROR: The CSV file was not found at: {csv_file_path}", file=sys.stderr)
        return np.array([]), np.array([])
    
    if not os.path.exists(spectrogram_dir):
        os.makedirs(spectrogram_dir)
        print(f"Created spectrograms directory at: {spectrogram_dir}")
    
    spectrogram_files = [f for f in os.listdir(spectrogram_dir) if f.lower().endswith('.npy')]
    
    if not spectrogram_files:
        print("No spectrograms found. Converting audio files to spectrograms...")
        audio_dir = os.path.join(audio_base_dir, 'clean')
        
        try:
            audio_files = os.listdir(audio_dir)
        except FileNotFoundError:
            print(f"ERROR: Audio directory not found: {audio_dir}", file=sys.stderr)
            return np.array([]), np.array([])
        
        for filename in audio_files:
            if filename.lower().endswith('.wav'):
                audio_path = os.path.join(audio_dir, filename)
                
                sample_rate, samples = wavfile.read(audio_path)
                if samples.dtype.kind == 'i':
                    samples = samples.astype(np.float32) / 32768.0
                _, _, Sxx = spectrogram(samples, fs=sample_rate)
                
                output_filename = os.path.splitext(filename)[0] + '.npy'
                np.save(os.path.join(spectrogram_dir, output_filename), Sxx)
                print(f"âœ… Converted and saved: {output_filename}")
    
    print("\nLoading spectrograms and metadata...")
    df_metadata['filename_key'] = df_metadata['clean_path'].apply(lambda x: os.path.splitext(os.path.basename(x))[0])
    df_metadata.set_index('filename_key', inplace=True)
    
    spectrograms = []
    t60_values = []
    
    for filename in os.listdir(spectrogram_dir):
        if filename.lower().endswith('.npy'):
            filename_key = os.path.splitext(filename)[0]
            try:
                spectrogram_path = os.path.join(spectrogram_dir, filename)
                spectrogram = np.load(spectrogram_path)
                
                if filename_key in df_metadata.index:
                    t60_value = df_metadata.loc[filename_key, 'Mean T60']
                    spectrograms.append(spectrogram)
                    t60_values.append(t60_value)
            except Exception as e:
                print(f"Skipping file due to an error: {filename} - {e}", file=sys.stderr)
    
    if not spectrograms:
        print("WARNING: No data was loaded.", file=sys.stderr)
        
    return np.array(spectrograms), np.array(t60_values)

# --- MODEL ARCHITECTURE ---
class SpectrogramProcessor(nn.Module):
    def __init__(self):
        super(SpectrogramProcessor, self).__init__()
        self.conv1 = nn.Conv2d(in_channels=1, out_channels=16, kernel_size=3, padding=1)
        self.conv2 = nn.Conv2d(in_channels=16, out_channels=32, kernel_size=3, padding=1)
        self.pool = nn.MaxPool2d(kernel_size=2, stride=2)
        self.relu = nn.ReLU()
    def forward(self, x):
        x = self.relu(self.conv1(x))
        x = self.pool(x)
        x = self.relu(self.conv2(x))
        x = self.pool(x)
        return x

class T60Processor(nn.Module):
    def __init__(self, t60_embedding_dim):
        super(T60Processor, self).__init__()
        self.t60_embedding = nn.Sequential(
            nn.Linear(1, t60_embedding_dim),
            nn.ReLU(),
            nn.Linear(t60_embedding_dim, t60_embedding_dim)
        )
    def forward(self, t60_value):
        t60_value = t60_value.view(-1, 1)
        embedding = self.t60_embedding(t60_value)
        return embedding

class CombinedModel(nn.Module):
    def __init__(self, t60_embedding_dim=64):
        super(CombinedModel, self).__init__()
        self.spectrogram_processor = SpectrogramProcessor()
        self.t60_processor = T60Processor(t60_embedding_dim)
        final_spectrogram_size = 32 * 64 * 250
        self.final_layer = nn.Sequential(
            nn.Linear(final_spectrogram_size + t60_embedding_dim, 1024),
            nn.ReLU(),
            nn.Linear(1024, 257 * 1000)
        )
    def forward(self, spectrogram, t60_value):
        processed_spectrogram = self.spectrogram_processor(spectrogram)
        processed_t60 = self.t60_processor(t60_value)
        processed_spectrogram = torch.flatten(processed_spectrogram, start_dim=1)
        combined_features = torch.cat((processed_spectrogram, processed_t60), dim=1)
        output = self.final_layer(combined_features)
        output = output.view(spectrogram.shape)
        return output

# --- TRAINING LOOP ---
def train_model(spectrograms_tensor, t60_tensor, num_epochs=10, learning_rate=0.001):
    model = CombinedModel()
    loss_function = nn.MSELoss()
    optimizer = optim.Adam(model.parameters(), lr=learning_rate)
    print("Starting training loop...")
    for epoch in range(num_epochs):
        predicted_spectrograms = model(spectrograms_tensor, t60_tensor)
        loss = loss_function(predicted_spectrograms, spectrograms_tensor)
        optimizer.zero_grad()
        loss.backward()
        optimizer.step()
        print(f'Epoch [{epoch+1}/{num_epochs}], Loss: {loss.item():.4f}')
    print("\nTraining complete!")

# --- MAIN EXECUTION BLOCK ---
if __name__ == "__main__":
    # --- CONFIGURATION ---
    audio_base_dir = 'my_project/dataset/'
    spectrogram_dir = 'my_project/dataset/spectrograms'
    csv_file_path = 'dereverb_dataset_1000_unique.csv'
    
    print("Loading data...")
    spectrograms, t60_values = load_data(audio_base_dir, spectrogram_dir, csv_file_path)
    
    if spectrograms.size > 0:
        spectrograms_tensor = torch.tensor(spectrograms, dtype=torch.float32).unsqueeze(1)
        t60_tensor = torch.tensor(t60_values, dtype=torch.float32)
        train_model(spectrograms_tensor, t60_tensor, num_epochs=20)
    else:
        print("No data to train on. Please check your data directory.", file=sys.stderr) 
